# Given a stack with initial configuration given by [a1,a0,b1,b0,...] where a = (a0,a1) and
# b = (b0,b1) represent elements in the extension field of degree 2, the procedure outputs the 
# product c = (c1,c0) where c0 = a0b0 - 2(a1b1) and c1 = (a0 + a1)(b0 + b1) - a0b0

proc.mul_ext_2
    dupw            #[a1,a0,b1,b0,a1,a0,b1,b0,...]
    swap.3          #[b0,a0,b1,a1,a1,a0,b1,b0,...]
    mul             #[b0a0,b1,a1,a1,a0,b1,b0,...]
    dup             #[b0a0,b0a0,b1,a1,a1,a0,b1,b0,...]
    movdn.7         #[b0a0,b1,a1,a1,a0,b1,b0,b0a0,...]
    movdn.2         #[b1,a1,b0a0,a1,a0,b1,b0,b0a0,...]
    mul.2           #[2b1,a1,b0a0,a1,a0,b1,b0,b0a0,...]
    mul             #[2b1a1,b0a0,a1,a0,b1,b0,b0a0,...]
    sub             #[b0a0-2b1a1,a1,a0,b1,b0,b0a0,...]
    movdn.5         #[a1,a0,b1,b0,b0a0,b0a0-2b1a1,...]
    add             #[a1+a0,b1,b0,b0a0,b0a0-2b1a1,...]
    swap.2          #[b0,b1,a1+a0,b0a0,b0a0-2b1a1,...]
    add             #[b0+b1,a1+a0,b0a0,b0a0-2b1a1,...]
    mul             #[(b0+b1)(a1+a0),b0a0,b0a0-2b1a1,...]
    swap            #[b0a0,(b0+b1)(a1+a0),b0a0-2b1a1,...]
    sub             #[(b0+b1)(a1+a0)-b0a0,b0a0-2b1a1,...]
end

# Given a stack with initial configuration given by [x,a1,a0,...] where a = (a0,a1) is an element
# in the field extension and x is an element of the base field, this procedure computes the multiplication
# of x, when looked at as (x,0), with a in the extension field. The output is [xa1,xa0,...]

proc.mul_base
    dup         #[x,x,a1,a0,...]
    movdn.3     #[x,a1,a0,x,...]
    mul         #[xa1,a0,x,...]
    movdn.2     #[a0,x,xa1,...]
    mul         #[xa0,xa1,...]
    swap        #[xa1,xa0,...]
end

# Given a stack with initial configuration given by [a1,a0,...] where a = (a0,a1) is an element
# in the field extension, calculate the result of applying the frobenius map to a
# input: [a1,a0,...]
# output: [-a1,a0+a1,...]

proc.frob
    dup         #[a1,a1,a0,...]
    movup.2     #[a0,a1,a1,...]
    add         #[a0+a1,a1,...]
    swap        #[a1,a0+a1,...]
    neg         #[-a1,a0+a1,...]
end

# Given a stack with initial configuration given by [a1,a0,...] where a = (a0,a1) is an element
# in the field extension, calculate the inverse of a.

proc.inv_ext
    dup                 #[a1,a1,a0,...]
    dup.2               #[a0,a1,a1,a0,...]
    swap                #[a1,a0,a1,a0,...]
    exec.frob           #[-a1,a0+a1,a1,a0,...]
    dup                 #[-a1,-a1,a0+a1,a1,a0,...]
    dup.2               #[a0+a1,-a1,-a1,a0+a1,a1,a0,...]
    swap                #[-a1,a0+a1,-a1,a0+a1,a1,a0,...]
    movup.5             #[a0,-a1,a0+a1,-a1,a0+a1,a1,...]
    movup.5             #[a1,a0,-a1,a0+a1,-a1,a0+a1,...]
    exec.mul_ext_2      #[z1,z0,-a1,a0+a1,...]
    drop                #[z0,-a1,a0+a1,...]
    inv                 #[z0^(-1),-a1,a0+a1,...]
    exec.mul_base       #[(-a1)z0^(-1),(a0+a1)z0^(-1),...]
end

# Given a stack in the following initial configuration [a1,a0,b1,b0,...] the following
# procedure computes [a1+b1,a0+b0,...]

proc.add_ext
    swap        #[a0,a1,b1,b0,...]
    movup.3     #[b0,a0,a1,b1,...]
    add         #[b0+a0,a1,b1,...]
    movdn.2     #[a1,b1,b0+a0,...]
    add         #[a1+b1,b0+a0,...]
end

# Given a stack in the following initial configuration [a1,a0,b1,b0,...] the following
# procedure computes [a1-b1,a0-b0,...]

proc.sub_ext
    swap        #[a0,a1,b1,b0,...]
    movup.3     #[b0,a0,a1,b1,...]
    sub         #[a0-b0,a1,b1,...]
    movdn.2     #[a1,b1,a0-b0,...]
    swap        #[b1,a1,a0-b0,...]
    sub         #[a1-b1,a0-b0,...]
end

# Given a stack in the following initial configuration [a1,a0,b1,b0,c1,c0,d1,d0,...] the following
# procedure computes (a + b + ((a - b) * c * d^(-1))) with the assumption that d1 is equal to 0

proc.fri
    dupw                #[a1,a0,b1,b0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    exec.sub_ext        #[(a-b)1,(a-b)0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    push.0.0            #[0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    movupw.2            #[c1,c0,d1,d0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.2             #[d1,c1,c0,d0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    drop                #[c1,c0,d0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.2             #[d0,c1,c0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    inv                 #[d0_inv,c1,c0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    exec.mul_base       #[y1,y0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.2             #[0,y1,y0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.3             #[0,0,y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    drop                #[0,y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    drop                #[y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    exec.mul_ext_2      #[w1,w0,a1,a0,b1,b0,...]
    exec.add_ext        #[v1,v0,b1,b0,...]
    exec.add_ext        #[o1,o0,...]
    push.9223372034707292161 #[2_inv,o1,o0]
    exec.mul_base
end

# Original implementation which uses unnecessary inversion in extension field.
proc.fri_original
    dupw                #[a1,a0,b1,b0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    exec.sub_ext        #[(a-b)1,(a-b)0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    push.0.0            #[0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    movupw.2            #[c1,c0,d1,d0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.2             #[d1,c1,c0,d0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.3             #[d0,d1,c1,c0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    swap                #[d1,d0,c1,c0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    exec.inv_ext        #[z1,z0,c1,c0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    exec.mul_ext_2      #[y1,y0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.2             #[0,y1,y0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.3             #[0,0,y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    drop                #[0,y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    drop                #[y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    exec.mul_ext_2      #[w1,w0,a1,a0,b1,b0,...]
    exec.add_ext        #[v1,v0,b1,b0,...]
    exec.add_ext        #[o1,o0,...]
    push.9223372034707292161 #[2_inv,o1,o0]
    exec.mul_base
    #swap
end

# This procedure computes the folded position in the exponent of the corresponding domain generator
# normalized by the offset. It uses an algebraic relationship between the original and folded positions
# given by multiplication with the 2nd primitive root of unity in our field.
# input:    #[?,poe,poe,...]
# output:   #[poe_sq,xs,...]
proc.next_pos_exp
    dup.1                               #[poe,?,poe,poe,...]   
    push.18446744069414584320           #[nor,poe,?,poe,poe,...]
    mul                                 #[poe/nor,?,poe,poe,...]
    swap                                #[?,poe/nor,poe,poe,...]
    cdrop                               #[xs,poe,...]
    mul.7                               #mul by offset 
    swap                                #[poe,xs,...]
    dup mul                             #[poe_sq,xs,...]
end

# Given a stack in the following initial configuration [d,p,C,t_d,e1,e0,poe,a1,a0,..] the following
# procedure computes an iteration of the fri verification for a query.
# some checks are needed in the beginning, like p < d (p&d are u32) and that 2^t_d == d 
proc.verify_query_layer
    u32unchecked_div.2                       #[d/2,p,C,t_d,...]
    dup                         #[d/2,d/2,p,C,t_d,...]
    dup.2 swap                  #[d/2,p,d/2,p,C,t_d,...]
    u32checked_divmod           #[p%d/2,?,d/2,p,C,t_d,...]
    swapw                       #[C,p%d/2,?,d/2,p,t_d,...]
    dup.4                       #[p%d/2,C,p%d/2,?,d/2,p,t_d,...]
    dup.9                       #[t_d,p%d/2,C,p%d/2,?,d/2,p,t_d,...]
    drop drop 

    # Here is the Merkle path auth. + Value unhashing
    dropw                       #[p%d/2,?,d/2,p,t_d,e1,e0,poe,a1,a0,...]
    push.0.0.0.0 adv_loadw      #[V,p%d/2,?,d/2,p,t_d,...]
    dupw  movdnw.2              #[v3,v2,v1,v0,p%d/2,?,d/2,p,V,t_d,...]

    movup.2 swap                #[v3,v1,v2,v0,p%d/2,?,d/2,p,V,t_d,...]
    dup.5                       #[?,v3,v1,v2,v0,p%d/2,?,d/2,p,V,t_d,...]
    cdrop                       #[v1,v2,v0,p%d/2,?,d/2,p,V,t_d,...]
    movdn.2                     #[v2,v0,v1,p%d/2,?,d/2,p,V,t_d,...]
    dup.4                       #[?,v2,v0,v1,p%d/2,?,d/2,p,V,t_d,...]
    cdrop   swap                #[v1,v0,p%d/2,?,d/2,p,V,t_d,...]
                                #[v1,v0,p%d/2,?,d/2,p,V,t_d,e1,e0..]
    dup                         #[v1,v1,v0,p%d/2,?,d/2,p,V,t_d,e1,e0..]
    movup.12                    #[e1,v1,v1,v0,p%d/2,?,d/2,p,t_d,e0..]
    assert_eq                   #[v1,v0,p%d/2,?,d/2,p,V,t_d,e0..]
    dup.1                       #[v0,v1,v0,p%d/2,?,d/2,p,V,t_d,e0..]
    movup.12                    #[e0,v0,v1,v0,p%d/2,?,d/2,p,V,t_d..]
    assert_eq                   #[v1,v0,p%d/2,?,d/2,p,V,t_d,poe,..] #poe is position in the exponent
    drop drop swapw             #[V,p%d/2,?,d/2,p,t_d,poe,..]
    movup.9                     #[poe,V,p%d/2,?,d/2,p,t_d,..]
    dup                         #[poe,poe,V,p%d/2,?,d/2,p,t_d,..]
    movup.7                     #[?,poe,poe,V,p%d/2,d/2,p,t_d,..]
    exec.next_pos_exp           #[poe_sq,xs,V,p%d/2,d/2,p,t_d,..]
    swap.8 drop                 #[xs,V,p%d/2,d/2,poe_sq,t_d,..]
    push.0                      #[0,xs,V,p%d/2,d/2,poe_sq,t_d,..]
                                #[0,xs,V,p%d/2,d/2,poe_sq,t_d,a1,a0,..]
    movup.11 movup.11           #[a1,a0,0,xs,v3,v2,v1,v0,p%d/2,d/2,poe_sq,t_d,..]   
    swapw                       #[v3,v2,v1,v0,a1,a0,0,xs,p%d/2,d/2,poe_sq,t_d,..] #Should simplify fri since d1 is always equal to zero
    movup.3 movup.3
    exec.fri                    #[e1,e0,p%d/2,d/2,poe_sq,t_d,..]
    movup.5 u32wrapping_sub.1   #[t_d-1,e1,e0,p%d/2,d/2,poe_sq,..]
                                                          
end

# Input: [n,g,...] n is greater than 0
# Output: [0,g^(2^n),...]
proc.exp_2_N
    swap                        #[g,n,...]
    dup mul                     #[g*g,n,...]
    swap                        #[n,g*g,...]
    u32wrapping_sub.1           #[n-1,g*g,...]
    dup                         #[n-1,n-1,g*g,...]
    push.0                      #[0,n-1,n-1,g*g,...]
    u32checked_neq              #[?,n-1,g*g,]
    while.true
        swap                    #[g,n,...]
        dup mul                 #[g*g,n,...]
        swap                    #[n,g*g,...]
        u32wrapping_sub.1       #[n-1,g*g,...]
        dup                     #[n-1,n-1,g*g,...]
        push.0                  #[0,n-1,n-1,g*g,...]
        u32checked_neq          #[?,n-1,g*g,]
    end
end

# Input: [g,x,...]
# Output: [g^x,...]
proc.exp_g_x
    push.1                      #[r,g,x,...]
    repeat.32
        movup.2                 #[x,r,g,...]
        dup u32unchecked_shr.1  #[x>>1,x,r,g,...]
        swap push.1         
        u32checked_and          #[x0, x>>1,r,g,...]   where x0 := x&1
        movup.2  dup            #[r,r,x0, x>>1 ,g,...]
        dup.4  mul              #[gr,r,x0, x>>1 ,g,...]
        movup.2                 #[x0,gr,r, x>>1 ,g,...]
        cdrop                   #[g^x0, x>>1 ,g,...]  
        movup.2 dup mul         #[g^2,g^x0, x>>1 ,...]
        swap                    #[g^x0,g^2, x>>1 ,...]
    end
    swap drop swap drop
end

# Input: [t_d,e1,e0,p,d,poe,..]
# Output: [d,p,C,t_d,e1,e0,poe,a1,a0,..]
proc.prepare_next
    adv_push.2                                #[a1,a0,t_d,e1,e0,p,d,poe,..]
    swapw                                     #[e0,p,d,poe,a,a,t_d,e1,..]
    push.0.0.0.0 adv_loadw                    #[C,e0,p,d,poe,a,a,t_d,e1,..]
    movup.5 movup.6                           #[d,p,C,e0,poe,a,a,t_d,e1,..]
    movup.11                                  #[e1,d,p,C,e0,poe,a,a,t_d,..]
    movdn.6                                   #[d,p,C,e1,e0,poe,a,a,t_d,..]
    movup.11                                  #[t_d,d,p,C,e1,e0,poe,a,a,..]
    movdn.6                                   #[d,p,C,t_d,e1,e0,poe,a1,a0,..]
end

# Prepare the stack by injecting advice inputs from the advice tape. Should check the relevant
# conditions on the loaded inputs.
# Input(Advice tape): [e1,e0,a1,a0,t_d,C,p,d,g,...]
# Output: [d,p,C,t_d,e1,e0,poe,a1,a0,...]
proc.prepare_initial
    push.0.0.0.0 adv_loadw
    adv_push.1
    push.0.0.0.0 adv_loadw
    adv_push.2              #[d,p,C,...]
    dup.1                   #[p,d,p,C,...]
    # Here we should probably check that p < d in u32 and that t_d is in u32 and that 2^t_d = d 
    adv_push.1              #[g,p,d,p,C,...]
    exec.exp_g_x            #[poe,d,p,C,t_d,e1,e0,a1,a0,...]
    movdn.9                 #[d,p,C,t_d,e1,e0,poe,a1,a0,...]
end

# Prepare the stack for the final remainder check to be executed once all queries
# have been processed. Assumes that the remainder has degree 0. In the case of 
# degree 2 we will need p and poe on the stack.
# Input: [t_d,e1,e0,p,d,poe,..]
# Output: #[e1,e0,..]
proc.prepare_final
    repeat.3
        movup.5
    end
    dropw
end

# Input: [e1,e0,e1,e0,e1,e0,e1,e0,e1,e0,e1,e0,...]
# Output: []
proc.verify_remainder
    repeat.4
        movup.2                     #[e1,v1,v0,e0,v1,v0,e1,e0,...]
        assert_eq                   #[v0,e0,v1,v0,e1,e0,...]
        assert_eq                   #[v1,v0,e1,e0,...]
    end
end


# Executes a full FRI verification for a single query.
proc.verify_query_full
    exec.prepare_initial    #[d,p,C,t_d,e1,e0,poe,a1,a0,...]
    dup push.16 neq         #[?,d,p,C,t_d,e1,e0,poe,a1,a0,...]

    while.true
        exec.verify_query_layer
        exec.prepare_next
        dup push.16 neq
    end

    exec.verify_query_layer
    exec.prepare_final

    # Final configuration
    # [e1,e0,..]
end

# Verify a FRI proof
export.verify_fri
    repeat.32
        exec.verify_query_full
    end
    dup.1
    dup.1
    adv_push.2
    repeat.16
        exec.verify_remainder
    end
end