use.std::math::ext2

#! Given a stack in the following initial configuration [a1,a0,b1,b0,c1,c0,d1,d0,...] the following
#! procedure computes (a + b + ((a - b) * c * d^(-1)))/2 with the assumption that d1 is equal to 0
export.fold_2
    dupw                #[a1,a0,b1,b0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    exec.ext2::sub      #[(a-b)1,(a-b)0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    push.0.0            #[0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,c1,c0,d1,d0,...]
    movupw.2            #[c1,c0,d1,d0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.2             #[d1,c1,c0,d0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    drop                #[c1,c0,d0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.2             #[d0,c1,c0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    inv                 #[d0_inv,c1,c0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    exec.ext2::mul_base       #[y1,y0,0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.2             #[0,y1,y0,0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    movup.3             #[0,0,y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    drop                #[0,y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    drop                #[y1,y0,(a-b)1,(a-b)0,a1,a0,b1,b0,...]
    exec.ext2::mul      #[w1,w0,a1,a0,b1,b0,...]
    exec.ext2::add      #[v1,v0,b1,b0,...]
    exec.ext2::add      #[o1,o0,...]
    push.9223372034707292161 #[2_inv,o1,o0]
    exec.ext2::mul_base
end

#! This procedure computes the folded position in the exponent of the corresponding domain generator
#! normalized by the offset. It uses an algebraic relationship between the original and folded positions
#! given by multiplication with the 2nd primitive root of unity in our field.
#! input:    #[?,poe,poe,...]
#! output:   #[poe_sq,xs,...]
export.next_pos_exp
    dup.1                               #[poe,?,poe,poe,...]   
    push.18446744069414584320           #[nor,poe,?,poe,poe,...]
    mul                                 #[poe/nor,?,poe,poe,...]
    swap                                #[?,poe/nor,poe,poe,...]
    cdrop                               #[xs,poe,...]
    mul.7                               #mul by offset 
    swap                                #[poe,xs,...]
    dup mul                             #[poe_sq,xs,...]
end

#! Preprocess the layer commitments C as well as num_q (number of queries), d (initial domain size),
#! g (intial domain generator), t_d (initial tree depth) and (a0,a1) (the folding challenges alpha).
#! The address of the word (num_q,d,g,t_d) will be at locaddr.0. The commitments and alphas will be
#! at the subsequent addresses. The total number of such commitments and alphas is t_d - 3 
#! (excluding the remainder commitment).
export.preprocess.1
    locaddr.0                   #[add,..]
    adv_push.4                  #[num_q,d,g,t_d,add,..]
    dup.3                       #[t_d,num_q,d,g,t_d,add,..]
    movdn.4                     #[num_q,d,g,t_d,t_d,add,..]
    dup.5                       #[add,num_q,d,g,t_d,t_d,add,..]
    mem_storew dropw            #[t_d,add,..]
    dup
    u32checked_neq.3            #[?,t_d,add,..]
    while.true
        push.0.0.0.0
        adv_loadw                       #[C,t_d,add,..]
        movup.5                         #[add,C,t_d,..]
        u32wrapping_add.1               #[add+1,C,t_d,..]
        dup movdn.6                     #[add+1,C,t_d,add+1,..]
        mem_storew                      #[C,t_d,add+1,..]
        adv_loadw                       #[0,0,a1,a0,t_d,add+1,..]
        movup.5                         #[add+1,0,0,a1,a0,t_d,..]
        u32wrapping_add.1               #[add+2,0,0,a1,a0,t_d,..]
        dup movdn.6                     #[add+2,0,0,a1,a0,t_d,add+2,..]
        mem_storew dropw                #[t_d,add+2,..]
        u32wrapping_sub.1 dup           #[t_d-1,t_d-1,add+2,..]
        u32checked_neq.3                #[?,t_d-1,add+2,..]
    end
    #[0,add,..]
    drop 
    add.1               # this address will be used for the adv_pipe instruction
    # value of the remainder codeword
    adv_push.2
    movup.2

    push.0.0.0.0
    locaddr.0
    mem_loadw
    locaddr.0
end

#! Helper procedure used to prepare the stack for the next iteration of verify_query_layer for a 
#! positon p. (add' - 2) is the address of the commitment for the next layer and (add' - 1) is 
#! the address of the next alpha folding challenge.
#! Input: [t_d,e1,e0,p,d,poe,add',..]
#! Output: [d,p,C,t_d,e1,e0,poe,a1,a0,add'-2,..]
proc.prepare_next
    movup.6                                 #[add',t_d,e1,e0,p,d,poe,..] where add' points to the address of the previous C
    sub.2 dup                               #[add'-2,add'-2,t_d,e1,e0,p,d,poe,..] add' - 2 now points to the new C
    movdn.7                                 #[add'-2,t_d,e1,e0,p,d,poe,add'-2,..]
    push.0.0.0.0                            #[0,0,0,0,add'-2,t_d,e1,e0,p,d,poe,add'-2,..]
    dup.4 add.1                             #[add'-1,0,0,0,0,add'-2,t_d,e1,e0,p,d,poe,add'-2,..]
    mem_loadw                               #[0,0,a1,a0,add'-2,t_d,e1,e0,p,d,poe,add'-2,..]
    push.0.0                                #[0,0,0,0,a1,a0,add'-2,t_d,e1,e0,p,d,poe,add'-2,..]
    movup.6                                 #[add'-2,0,0,0,0,a1,a0,t_d,e1,e0,p,d,poe,add'-2,..]
    mem_loadw                               #[C,a1,a0,t_d,e1,e0,p,d,poe,add'-2,..]
    swapw.2                                 #[e0,p,d,poe,a1,a0,t_d,e1,C,add'-2,..]
    swap.2                                  #[d,p,e0,poe,a1,a0,t_d,e1,C,add'-2,..]
    movup.7                                 #[e1,d,p,e0,poe,a1,a0,t_d,C,add'-2,..]
    movup.7                                 #[t_d,e1,d,p,e0,poe,a1,a0,C,add'-2,..]
    movupw.2                                #[C,t_d,e1,d,p,e0,poe,a1,a0,add'-2,..]
    movup.7                                 #[p,C,t_d,e1,d,e0,poe,a1,a0,add'-2,..]
    movup.7                                 #[d,p,C,t_d,e1,e0,poe,a1,a0,add'-2,..]
end

#! The following procedure computes an iteration of FRI verification for a query.
#! The stack starts in the following initial configuration [d,p,C,t_d,e1,e0,poe,a1,a0,..] where d is 
#! the current domain size, p the current position, C is the commitment of current layer, t_d 
#! its corresponding tree depth, (e1,e0) is the evaluation point, poe is the position in the exponent
#! of the domain generator, (a1,a0) is the alpha to compute the next evaluation point.
#! TODO: Check where/if some checks are needed at the beginning, like p < d (p&d are u32) and that 2^t_d == d 
#! Input: #[d,p,C,t_d,e1,e0,poe,a1,a0,add',add_f..]
#! Output: #[t_d-1,e1,e0,p%d/2,d/2,poe_sq,add',add_f..]
export.verify_query_layer
    u32unchecked_div.2          #[d/2,p,C,t_d,...]
    #dup                         #[d/2,d/2,p,C,t_d,...]
    #dup.2 swap                  #[d/2,p,d/2,p,C,t_d,...]
    #u32checked_divmod           #[p%d/2,?,d/2,p,C,t_d,...]
    #swapw                       #[C,p%d/2,?,d/2,p,t_d,...]
    #dup.4                       #[p%d/2,C,p%d/2,?,d/2,p,t_d,...]
    #dup.9                       #[t_d,p%d/2,C,p%d/2,?,d/2,p,t_d,...]
    #mtree_get  swapw            #[C,V',p%d/2,?,d/2,p,t_d,...]  V' are the digest of values V = (v3,v2,v1,v0)
    
    #dropw
    #adv.keyval                  # load the leaf values onto the adv tape
                                ##[V',p%d/2,?,d/2,p,t_d,e1,e0,poe,a1,a0,add',add_f,...]

    #dup.15                      #[add_f,V',p%d/2,?,d/2,p,t_d,e1,e0,poe,a1,a0,add',add_f,...]

    #push.4.0.0.0                #[0,0,0,4,add_f,V',p%d/2,?,d/2,p,t_d,...]
    #push.0.0.0.0.0.0.0.0        #[0,0,0,0,0,0,0,0,0,0,0,4,add_f,V',p%d/2,?,d/2,p,t_d,...]
    #adv_pipe                    #[T,D,S,add_f,V',p%d/2,?,d/2,p,t_d,...]
    #dropw swapw dropw           #[D,add_f,V',p%d/2,?,d/2,p,t_d,...]
    #movup.4  movdn.8            #[D,V',add_f,p%d/2,?,d/2,p,t_d,...]
    #eqw drop dropw movup.4      #[add_f,V',p%d/2,?,d/2,p,t_d,...]
    #sub.2 mem_loadw             #[V,p%d/2,?,d/2,p,t_d,...]

    #dupw  movdnw.2              #[v3,v2,v1,v0,p%d/2,?,d/2,p,V,t_d,...]
    #movup.2 swap                #[v3,v1,v2,v0,p%d/2,?,d/2,p,V,t_d,...]
    #dup.5                       #[?,v3,v1,v2,v0,p%d/2,?,d/2,p,V,t_d,...]
    #cdrop                       #[v1,v2,v0,p%d/2,?,d/2,p,V,t_d,...]
    #movdn.2                     #[v2,v0,v1,p%d/2,?,d/2,p,V,t_d,...]
    #dup.4                       #[?,v2,v0,v1,p%d/2,?,d/2,p,V,t_d,...]
    #cdrop   swap                #[v1,v0,p%d/2,?,d/2,p,V,t_d,...]
                                ##[v1,v0,p%d/2,?,d/2,p,V,t_d,e1,e0..]
    #dup                         #[v1,v1,v0,p%d/2,?,d/2,p,V,t_d,e1,e0..]
    #movup.12                    #[e1,v1,v1,v0,p%d/2,?,d/2,p,t_d,e0..]
    #assert_eq                   #[v1,v0,p%d/2,?,d/2,p,V,t_d,e0..]
    #dup.1                       #[v0,v1,v0,p%d/2,?,d/2,p,V,t_d,e0..]
    #movup.12                    #[e0,v0,v1,v0,p%d/2,?,d/2,p,V,t_d..]
    #assert_eq                   #[v1,v0,p%d/2,?,d/2,p,V,t_d,poe,..] #poe is position in the exponent
    #drop drop swapw             #[V,p%d/2,?,d/2,p,t_d,poe,..]
    #movup.9                     #[poe,V,p%d/2,?,d/2,p,t_d,..]
    #dup                         #[poe,poe,V,p%d/2,?,d/2,p,t_d,..]
    #movup.7                     #[?,poe,poe,V,p%d/2,d/2,p,t_d,..]
    #exec.next_pos_exp           #[poe_sq,xs,V,p%d/2,d/2,p,t_d,..]
    #swap.8 drop                 #[xs,V,p%d/2,d/2,poe_sq,t_d,..]
    #push.0                      #[0,xs,V,p%d/2,d/2,poe_sq,t_d,..]
                                ##[0,xs,V,p%d/2,d/2,poe_sq,t_d,a1,a0,..]
    #movup.11 movup.11           #[a1,a0,0,xs,v3,v2,v1,v0,p%d/2,d/2,poe_sq,t_d,..]   
    #swapw                       #[v3,v2,v1,v0,a1,a0,0,xs,p%d/2,d/2,poe_sq,t_d,..] #Should simplify fri since d1 is always equal to zero
    #movup.3 movup.3
    #exec.fold_2                 #[e1,e0,p%d/2,d/2,poe_sq,t_d,..]
    #movup.5 u32wrapping_sub.1   #[t_d-1,e1,e0,p%d/2,d/2,poe_sq,add',..]
    

end

#! Verify a single query. The expected stack configuration is [add,num_q,d,g,t_d,add',...]
#! where add is the address storing the current (num_q,d,g,t_d), num_q is the index of the current query,
#! d is the domain size of the LDE, g is its generator and add' is the address of the commitment to 
#! the first layer with the commitments to subsequent layers laid out, in alternating order with the layer
#! alphas, in the subsequent addresses i.e. add' - 2, add' - 1 ...
#! Input:  #[d,p,C,t_d,e1,e0,poe,a1,a0,add_f - 2,add_f,add_i,...]
#! Output: #[p%d/2,d/2,poe_sq,add_i + 1,add_f,add_i,rem1,rem0...]
export.verify_query
    exec.verify_query_layer
    #[t_d-1,e1,e0,p%d/2,d/2,poe_sq,add',..]

    #dup u32checked_neq.3
    #while.true
        #exec.prepare_next
        #exec.verify_query_layer
        #dup u32checked_neq.3
    #end

    ### Verify remainder 
    #drop
    #dup.8 assert_eq
    #dup.8 assert_eq
end

#! Verify that the hash of the remainder codeword is equal to the commitment provided by the prover
#! The following implementation relies on the assumption that the blowup factor is 8 and that the degree
#! of the remainder is zero.
#! Input: #[p%d/2,d/2,poe_sq,add_i + 1,add_f,add_i,rem1,rem0...]
#! Output: ()
export.verify_remainder_com
    dropw                  #[r1,r0,..]
    drop drop
    dup.1 dup.1
    push.4.0.0.0
    swapw
    push.0.0.0.0

    # compute the leaf
    rpperm
    dropw swapw dropw

    # compute the Merkle tree root
    dupw rphash     
    dupw rphash
    push.0.0.0.0
    adv_loadw
    eqw
    assert
    dropw dropw
end

#! This procedure verifies a FRI proof with number of queries num_q, initial domain size d, generator
#! for this domain g, and tree depth of the initial layer Merkle tree commitment. add_i points to
#! the address containing values common to all queries as well as to keep track of the queries
#! that remain to be verified. add_f points to the address that will contain the result of adv_pipe.
#! add_f - 2 * i - 2 points to the layer folding challenges alpha and add_f - 2 * i - 1 points to
#! the i-th layer commitment.
#! Input: #[add_i,num_q,d,g,t_d,add_f,...]
#! Output: ()
export.verify_fri
    #push.1
    #while.true
        dup                         #[add_i,add_i,num_q,d,g,t_d,add_f,...]
        movdn.6                     #[add_i,num_q,d,g,t_d,add_f,add_i,...]
        mem_storew                  #[num_q,d,g,t_d,...]
        push.0.0.0
        adv_loadw                   #[0,p,e1,e0,d,g,t_d,...]
        drop                        #[p,e1,e0,d,g,t_d,...]
        dup                         #[p,p,e1,e0,d,g,t_d,...]
        movup.5                     #[g,p,p,e1,e0,d,t_d,...]
        swap                        #[p,g,p,e1,e0,d,t_d,...]
        exp.u32                #[poe,p,e1,e0,d,t_d,...]
                
        #dup.6                       #[add_f,poe,p,e1,e0,d,t_d,add_f,...]
        #sub.2 dup                   #[add_f - 2,add_f - 2,poe,p,e1,e0,d,t_d,add_f,...]
        #movdn.7                     #[add_f - 2,poe,p,e1,e0,d,t_d,add_f - 2,add_f,...]
        #push.0.0.0.0                #[0,0,0,0,add_f - 2,poe,p,e1,e0,d,t_d,add_f - 2,...]
        #dup.4  add.1                #[add_f - 1,0,0,0,0,add_f - 2,poe,p,e1,e0,d,t_d,add_f - 2,...]
        #mem_loadw                   #[0,0,a1,a0,add_f - 2,poe,p,e1,e0,d,t_d,add_f - 2,...]
        #push.0.0                    #[0,0,0,0,a1,a0,add_f - 2,poe,p,e1,e0,d,t_d,add_f - 2,...]
        #movup.6                     #[add_f - 2,0,0,0,0,a1,a0,poe,p,e1,e0,d,t_d,add_f - 2,...]
        #mem_loadw                   #[C,a1,a0,poe,p,e1,e0,d,t_d,add_f - 2,...]

        
        #swapw.2 swapw           #[a1,a0,poe,p,e1,e0,d,t_d,C,add_f - 2,...]
        #movup.2                 #[poe,a1,a0,p,e1,e0,d,t_d,C,add_f - 2,...]
        #movup.5                 #[e0,poe,a1,a0,p,e1,d,t_d,C,add_f - 2,...]
        #swapw                   #[p,e1,d,t_d,e0,poe,a1,a0,C,add_f - 2,...]
        #movupw.2                #[C,p,e1,d,t_d,e0,poe,a1,a0,add_f - 2,...]
        #movup.4                 #[p,C,e1,d,t_d,e0,poe,a1,a0,add_f - 2,...]
        #movup.6                 #[d,p,C,e1,t_d,e0,poe,a1,a0,add_f - 2,...]
        #movup.6                 #[e1,d,p,C,t_d,e0,poe,a1,a0,add_f - 2,...]
        #movdn.7                 #[d,p,C,t_d,e1,e0,poe,a1,a0,add_f - 2,add_f,add_i,...]

        ### Prepare initial is done for query p
        ## Call verify query full by iterating verify query layer 
        #exec.verify_query

        ### Prepare for next iteration of while loop
        ##[p%d/2,d/2,poe_sq,add_i + 1,add_f,add_i,rem1,rem0...]
        #dup.5                  #[add_i,p%d/2,d/2,poe_sq,add_i + 1,add_f,add_i,rem1,rem0...]
        #mem_loadw
        #sub.1 
        #dup
        #neq.0                  #[?,num_q-1,d,g,t_d,add_f,add_i,rem1,rem0,...]
        #movup.6 swap           #[?,add_i,num_q-1,d,g,t_d,add_f,rem1,rem0,...]
    #end

    #exec.verify_remainder_com
end