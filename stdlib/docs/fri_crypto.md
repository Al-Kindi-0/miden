
## std::crypto::fri
| Procedure | Description |
| ----------- | ------------- |
| fold_2 | Given a stack in the following initial configuration [a1,a0,b1,b0,c1,c0,d1,d0,...] the following<br /><br />procedure computes (a + b + ((a - b) * c * d^(-1)))/2 with the assumption that d1 is equal to 0 |
| next_pos_exp | This procedure computes the folded position in the exponent of the corresponding domain generator<br /><br />normalized by the offset. It uses an algebraic relationship between the original and folded positions<br /><br />given by multiplication with the 2nd primitive root of unity in our field.<br /><br />input:    #[?,poe,poe,...]<br /><br />output:   #[poe_sq,xs,...] |
| preprocess | Preprocess the layer commitments C as well as num_q (number of queries), d (initial domain size),<br /><br />g (intial domain generator), t_d (initial tree depth) and (a0,a1) (the folding challenges alpha).<br /><br />The address of the word (num_q,d,g,t_d) will be at locaddr.0. The commitments and alphas will be<br /><br />at the subsequent addresses. The total number of such commitments and alphas is t_d - 3<br /><br />(excluding the remainder commitment). |
| verify_query_layer | The following procedure computes an iteration of FRI verification for a query.<br /><br />The stack starts in the following initial configuration [d,p,C,t_d,e1,e0,poe,a1,a0,..] where d is<br /><br />the current domain size, p the current position, C is the commitment of current layer, t_d<br /><br />its corresponding tree depth, (e1,e0) is the evaluation point, poe is the position in the exponent<br /><br />of the domain generator, (a1,a0) is the alpha to compute the next evaluation point.<br /><br />TODO: Check where/if some checks are needed at the beginning, like p < d (p&d are u32) and that 2^t_d == d<br /><br />Input: #[d,p,C,t_d,e1,e0,poe,a1,a0,add',add_f..]<br /><br />Output: #[t_d-1,e1,e0,p%d/2,d/2,poe_sq,add',add_f..] |
| verify_query | Verify a single query. The expected stack configuration is [add,num_q,d,g,t_d,add',...]<br /><br />where add is the address storing the current (num_q,d,g,t_d), num_q is the index of the current query,<br /><br />d is the domain size of the LDE, g is its generator and add' is the address of the commitment to<br /><br />the first layer with the commitments to subsequent layers laid out, in alternating order with the layer<br /><br />alphas, in the subsequent addresses i.e. add' - 2, add' - 1 ...<br /><br />Input:  #[d,p,C,t_d,e1,e0,poe,a1,a0,add_f - 2,add_f,add_i,...]<br /><br />Output: #[p%d/2,d/2,poe_sq,add_i + 1,add_f,add_i,rem1,rem0...] |
| verify_remainder_com | Verify that the hash of the remainder codeword is equal to the commitment provided by the prover<br /><br />The following implementation relies on the assumption that the blowup factor is 8 and that the degree<br /><br />of the remainder is zero.<br /><br />Input: #[p%d/2,d/2,poe_sq,add_i + 1,add_f,add_i,rem1,rem0...]<br /><br />Output: () |
| verify_fri | This procedure verifies a FRI proof with number of queries num_q, initial domain size d, generator<br /><br />for this domain g, and tree depth of the initial layer Merkle tree commitment. add_i points to<br /><br />the address containing values common to all queries as well as to keep track of the queries<br /><br />that remain to be verified. add_f points to the address that will contain the result of adv_pipe.<br /><br />add_f - 2 * i - 2 points to the layer folding challenges alpha and add_f - 2 * i - 1 points to<br /><br />the i-th layer commitment.<br /><br />Input: #[add_i,num_q,d,g,t_d,add_f,...]<br /><br />Output: () |
